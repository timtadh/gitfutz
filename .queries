commits=for 
  commit in repo.walk(
            repo.lookup_reference('HEAD').resolve().oid, 
            pygit2.GIT_SORT_TOPOLOGICAL) 
  let walk_tree = function(tree) {
    for entry in tree
      let eobj = entry.to_object() 
      return "name"     : entry.name.encode("utf8"), 
             "contents" : if (isinstance(eobj, pygit2.Tree))
                          then walk_tree(eobj)
                          else eobj.data
  }
  let diff_trees = function(A, B) {
    for a in A, b in B
      let a_name = a.name.encode('utf8')
      let b_name = b.name.encode('utf8')
      let a_eobj = a.to_object()
      let b_eobj = b.to_object()
      where a_name == b_name and
            a_eobj.__class__ == b_eobj.__class__ and
            (isinstance(a_eobj, pygit2.Tree) or a_eobj.data != b_eobj.data)
      return "name" : a_name,
             "diff" : if (isinstance(a_eobj, pygit2.Tree))
                      then diff_trees(a_eobj, b_eobj)
                      else null
  }
  let commit_id = commit.hex
  let author = commit.author.name.encode('utf8')
  where author.__contains__('Tim')
  return commit_id, author, {
    for parent in commit.parents
      return diff_trees(commit.tree, parent.tree)
  }
------------
mine_calls=for 
  commit in repo.walk(
            repo.lookup_reference('HEAD').resolve().oid, 
            pygit2.GIT_SORT_TOPOLOGICAL) 
  let allowed_exts = set(['.py', ''])
  let collect_calls = function(node, i) {
    for kid in node.children
    return flatten if kid.label == 'Call'
                   then tuple([kid] + list(collect_calls(kid, i+1)))
                   else collect_calls(kid, i+1)
  }
  let collect_python = function(tree, parents) {
    for entry in tree
      let eobj = if entry.oid in repo then entry.to_object() else None
      let name = entry.name.encode("utf8") 
      let ext  = os.path.splitext(name)[1]
      let path = os.path.join(parents, name)
      let file = if hasattr(eobj, 'data') and ext in allowed_exts
                 then eobj.data 
                 else None
      let line = if file != None 
                 then file.split('\n')[0]
                 else None
      let line = if line != None and len(line) > 2 then line else None
      where eobj != None and 
            (isinstance(eobj, pygit2.Tree) or 
              ext == '.py' or 
              (file != None and line.__getslice__(0,2) == '#!' and "python" in line)
            )
      return flatten if isinstance(eobj, pygit2.Tree)
                     then collect_python(eobj, path)
                     else {
                       'path':path,
                       'file':file,
                       'ast': gitfutz.astutils.genast.python(file)[0]
                     }
  }
  let commit_id = commit.hex
  let author = commit.author.name.encode('utf8')
  let pyfiles = collect_python(commit.tree, '')
  let calls = {
    for file in pyfiles
    let _ = log(file["path"])
    where file["ast"] != None
    return "path":file["path"], "calls":collect_calls(file["ast"], 1)
  }
  return commit_id, author, calls
------------
sequence=for
  commit in repo.walk(
            repo.lookup_reference('HEAD').resolve().oid,
            pygit2.GIT_SORT_TOPOLOGICAL)
  let diff_trees = function(A, B, parents) {
    for a in A, b in B
      let a_name = a.name.encode('utf8')
      let b_name = b.name.encode('utf8')
      let a_eobj = if a.oid in repo then a.to_object() else None
      let b_eobj = if b.oid in repo then b.to_object() else None
      let path = os.path.join(parents, a_name)
      let ext = os.path.splitext(a_name)[1]
      let _ =
          if a_eobj != None and b_eobj != None and
            a_name == b_name and
            a_eobj.__class__ == b_eobj.__class__ and
            ext not in <excluded_exts> and
            path not in <excluded_files> and
            (not isinstance(a_eobj, pygit2.Tree) and a_eobj.data != b_eobj.data)
          then log(' '*4, path)
          else None
      where a_eobj != None and b_eobj != None and
            a_name == b_name and
            a_eobj.__class__ == b_eobj.__class__ and
            ext not in <excluded_exts> and
            path not in <excluded_files> and
            (isinstance(a_eobj, pygit2.Tree) or a_eobj.data != b_eobj.data)
      return flatten
        if (isinstance(a_eobj, pygit2.Tree))
        then diff_trees(a_eobj, b_eobj, path)
        else {
          "path" : path,
          "dist" : strdist(a_eobj.data, b_eobj.data)
        }
  }
  let commit_id = commit.hex
  let author = commit.author.name.encode('utf8')
  let merge = (if len(commit.parents) > 1 then 1 else 0)
  let _ = log(commit_id, author)
  let dist = sum({
    for parent in commit.parents
    return flatten {
      for d in diff_trees(commit.tree, parent.tree, '')
      return d["dist"]
    }
  })
collect "dist":dist, "commits":1, "merges":merge
  as author with function(p, n) {
    if p == None
    then n
    else {
      "dist": p["dist"] + n["dist"],
      "commits": p["commits"] + n["commits"],
      "merges": p["merges"] + n["merges"]
    }
  }
------------
